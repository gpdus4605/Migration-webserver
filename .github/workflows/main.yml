# 워크플로우의 이름을 지정합니다. GitHub Actions 탭에 이 이름이 표시됩니다.
name: CI/CD for On-premise Webservice

# 워크플로우가 시작될 조건을 지정합니다.
on:
  # 'main' 브랜치에 push 이벤트가 발생했을 때 실행됩니다.
  push:
    branches: [ "main" ]

# 워크플로우에서 실행될 작업(job)들을 정의합니다.
jobs:
  # 1. CI: Docker 이미지를 빌드하고 Docker Hub에 푸시하는 작업
  build-and-push:
    # 이 작업이 실행될 가상 환경을 지정합니다. (최신 우분투)
    runs-on: ubuntu-latest
    steps:
      # 1-1. 소스 코드 체크아웃
      # GitHub Repository에 있는 코드를 가상 환경으로 가져옵니다.
      - name: Checkout source code
        uses: actions/checkout@v4

      # 1-2. Docker Hub 로그인
      # GitHub Secrets에 저장된 Docker Hub 계정 정보를 사용하여 로그인합니다.
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # 1-3. Docker 이미지 빌드 및 푸시
      # Dockerfile을 사용하여 이미지를 빌드하고, Docker Hub에 푸시합니다.
      # 이미지 태그는 고유성을 위해 Git 커밋 해시(SHA)를 사용합니다.
      - name: Build and push Docker image
        run: |
          cd backend
          docker buildx build --file Dockerfile \
            --tag ${{ secrets.DOCKER_USERNAME }}/onpremise-webservice:${{ github.sha }} \
            --push .

  # 2. CD: 운영 서버에 접속하여 최신 버전으로 배포하는 작업
  deploy:
    # 'build-and-push' 작업이 성공적으로 완료되어야 이 작업이 실행됩니다.
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      # 2-1. AWS 자격 증명 설정
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # 2-2. 배포 스크립트 실행 (Git pull, .env 생성, 서비스 재시작)
      - name: Execute deployment script
        run: |
          # .env 파일 내용을 Base64로 인코딩합니다.
          ENCODED_ENV=$(echo "${{ secrets.ENV_FILE_CONTENT }}" | base64 -w 0)

          # EC2 인스턴스에서 실행할 셸 스크립트를 하나의 문자열로 정의합니다.
          # 원격지에서 확장될 변수는 $ 대신 \$로 이스케이프 처리합니다.
          REMOTE_SCRIPT=$(cat <<EOF
          set -e
          echo "### Starting deployment script on EC2 instance."

          # Define variables for clarity. These are expanded on the remote host.
          APP_USER='${{ secrets.SSH_USERNAME }}'
          TARGET_DIR="/home/\$APP_USER/onpremise-webservice"

          # Part 0: Fix permissions. This is the most important step.
          echo "### Ensuring correct ownership of \$TARGET_DIR..."
          chown -R \$APP_USER:\$APP_USER "\$TARGET_DIR" || true

          # Part 1: Clone or Pull, running as the correct user.
          if ! sudo -u \$APP_USER test -d "\$TARGET_DIR"; then
            echo "### Cloning repository..."
            sudo -u \$APP_USER git clone "https://github.com/${{ github.repository }}.git" "\$TARGET_DIR"
          else
            echo "### Setting remote URL to ensure it's correct..."
            sudo -u \$APP_USER git -C "\$TARGET_DIR" remote set-url origin "https://github.com/${{ github.repository }}.git"
            echo "### Pulling latest code..."
            sudo -u \$APP_USER git -C "\$TARGET_DIR" pull origin main
          fi

          # Part 2: Create the .env file as the correct user.
          echo "### Creating .env file..."
          echo "$ENCODED_ENV" | base64 --decode | sudo -u \$APP_USER tee "\$TARGET_DIR/.env" > /dev/null

          # Part 3: Run the deployment as root.
          echo "### Running deployment script as root..."
          cd "\$TARGET_DIR/backend"
          export GITHUB_SHA="${{ github.sha }}"
          export SLACK_WEBHOOK_URL="${{ secrets.SLACK_WEBHOOK_URL }}"
          bash deploy.sh

          echo "### Deployment script finished."
          EOF
          )

          # AWS CLI에 전달할 ssm-params.json 파일을 생성합니다.
          # jq를 사용하여 REMOTE_SCRIPT를 JSON에 안전하게 삽입합니다.
          jq -n --arg script "$REMOTE_SCRIPT" \
            --argjson instance_ids '["${{ secrets.AWS_INSTANCE_ID }}"]' \
            '{ "DocumentName": "AWS-RunShellScript", "InstanceIds": $instance_ids, "Parameters": { "commands": [$script] } }' \
            > ssm-params.json

          echo "### Generated ssm-params.json:"
          cat ssm-params.json

          # --cli-input-json 옵션을 사용하여 원격 스크립트를 실행합니다.
          COMMAND_ID=$(aws ssm send-command \
            --cli-input-json file://ssm-params.json \
            --output text --query "Command.CommandId")

          echo "SSM Command ID for deployment: $COMMAND_ID"

          # 명령이 끝날 때까지 대기하고, 실패 시 로그를 가져옵니다.
          if ! aws ssm wait command-executed --command-id "$COMMAND_ID" --instance-id "${{ secrets.AWS_INSTANCE_ID }}"; then
            echo "--- Deployment failed. Fetching logs from SSM ---"
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ secrets.AWS_INSTANCE_ID }}" \
              --query "StandardErrorContent" \
              --output text
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ secrets.AWS_INSTANCE_ID }}" \
              --query "StandardOutputContent" \
              --output text
            exit 1
          fi

          echo "### Deployment command sent and executed successfully."