# 워크플로우의 이름을 지정합니다. GitHub Actions 탭에 이 이름이 표시됩니다.
name: CI/CD for On-premise Webservice

# 워크플로우가 시작될 조건을 지정합니다.
on:
  # 'main' 브랜치에 push 이벤트가 발생했을 때 실행됩니다.
  push:
    branches: [ "main" ]

# 워크플로우에서 실행될 작업(job)들을 정의합니다.
jobs:
  # 1. CI: Docker 이미지를 빌드하고 Docker Hub에 푸시하는 작업
  build-and-push:
    # 이 작업이 실행될 가상 환경을 지정합니다. (최신 우분투)
    runs-on: ubuntu-latest
    steps:
      # 1-1. 소스 코드 체크아웃
      # GitHub Repository에 있는 코드를 가상 환경으로 가져옵니다.
      - name: Checkout source code
        uses: actions/checkout@v4

      # 1-2. Docker Hub 로그인
      # GitHub Secrets에 저장된 Docker Hub 계정 정보를 사용하여 로그인합니다.
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # 1-3. Docker 이미지 빌드 및 푸시
      # Dockerfile을 사용하여 이미지를 빌드하고, Docker Hub에 푸시합니다.
      # 이미지 태그는 고유성을 위해 Git 커밋 해시(SHA)의 앞 7자리를 사용합니다.
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/onpremise-webservice:${{ github.sha }}

  # 2. CD: 운영 서버에 접속하여 최신 버전으로 배포하는 작업
  deploy:
    # 'build-and-push' 작업이 성공적으로 완료되어야 이 작업이 실행됩니다.
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      # 2-1. 소스 코드 체크아웃 (deploy.sh 파일을 읽기 위해 필요)
      - name: Checkout source code
        uses: actions/checkout@v4

      # 2-2. AWS 자격 증명 설정
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # 2-3. 배포 스크립트 파일 내용 읽기
      # actions/github-script를 사용하여 deploy.sh 파일의 내용을 읽고,
      # 이 작업(job)의 출력(output)으로 설정합니다.
      - name: Read deploy script file
        id: script_reader
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const scriptContent = fs.readFileSync('deploy.sh', 'utf8');
            core.setOutput('script', scriptContent);

      # 2-4. AWS CLI를 사용하여 원격 서버에 배포 스크립트 실행
      - name: Deploy to server via AWS CLI and SSM
        run: |
          # 셸 파싱 오류를 원천적으로 방지하기 위해, 복잡한 문자열들을 Base64로 인코딩합니다.
          # -w 0 옵션은 인코딩된 결과가 여러 줄로 나뉘지 않도록 합니다.
          ENCODED_ENV=$(echo "${{ secrets.ENV_FILE_CONTENT }}" | base64 -w 0)
          ENCODED_SCRIPT=$(echo "${{ steps.script_reader.outputs.script }}" | base64 -w 0)

          # 1단계: Git Clone 또는 Pull을 수행하는 명령
          # workingDirectory가 /home/ubuntu이므로, 이 위치에서 git 작업을 먼저 수행합니다.
          GIT_COMMAND="if [ ! -d 'onpremise-webservice' ]; then git clone https://github.com/${{ github.repository }}.git onpremise-webservice; else cd onpremise-webservice && git pull origin main; fi"

          # 2단계: 프로젝트 디렉터리 내에서 실제 배포 스크립트를 실행하는 명령
          # export한 환경 변수가 bash 스크립트 내에서 유효하도록 세미콜론으로 연결합니다.
          DEPLOY_COMMAND="export GITHUB_REPOSITORY='${{ github.repository }}'; \
                          export GITHUB_SHA='${{ github.sha }}'; \
                          export ENV_FILE_CONTENT='$ENCODED_ENV'; \
                          echo '$ENCODED_SCRIPT' | base64 --decode | bash"
          
          # 1단계 실행
          aws ssm send-command --instance-ids "${{ secrets.AWS_INSTANCE_ID }}" --document-name "AWS-RunShellScript" --parameters "{\"workingDirectory\":[\"/home/${{ secrets.SSH_USERNAME }}\"],\"commands\":[\"$GIT_COMMAND\"]}" --output text > /dev/null
          sleep 5 # Git 작업이 완료될 시간을 줍니다.

          # 2단계 실행 (배포)
          # 이제 workingDirectory를 프로젝트 폴더로 지정하여 모든 명령이 해당 폴더 내에서 실행되도록 합니다.
          COMMANDS_JSON=$(printf '%s' "$DEPLOY_COMMAND" | jq -R . | jq -s .)

          # AWS CLI를 직접 사용하여 SSM SendCommand를 실행합니다.
          # --output text로 CommandId만 추출하고, 이 ID를 사용하여 명령이 끝날 때까지 기다립니다.
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ secrets.AWS_INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --parameters "{\"workingDirectory\":[\"/home/${{ secrets.SSH_USERNAME }}/onpremise-webservice\"],\"commands\":$COMMANDS_JSON}" \
            --output text --query "Command.CommandId")

          echo "SSM Command ID: $COMMAND_ID"

          # 명령이 끝날 때까지 대기합니다. (최대 5분)
          aws ssm wait command-executed --command-id "$COMMAND_ID" --instance-id "${{ secrets.AWS_INSTANCE_ID }}"

          # 명령 실행 결과를 확인하고, 실패 시 워크플로우를 중단시킵니다.
          aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "${{ secrets.AWS_INSTANCE_ID }}"
          OUTPUT=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "${{ secrets.AWS_INSTANCE_ID }}" --query "StandardOutputContent")
          echo "$OUTPUT"
          STATUS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "${{ secrets.AWS_INSTANCE_ID }}" --query "Status")
          if [ "$STATUS" != "Success" ]; then
            echo "Deployment script failed with status: $STATUS"
            echo "--- Fetching deployment logs from server (/tmp/deploy.log) ---"
            # 로그를 가져오는 명령을 보내고 CommandId를 받습니다.
            LOG_COMMAND_ID=$(aws ssm send-command \
              --instance-ids "${{ secrets.AWS_INSTANCE_ID }}" \
              --document-name "AWS-RunShellScript" \
              --parameters "commands=['cat /tmp/deploy.log']" \
              --query "Command.CommandId" --output text)
            
            # 로그를 가져오는 명령이 끝날 때까지 잠시 기다립니다.
            sleep 3
            # 해당 명령의 실행 결과를 가져와서 출력합니다.
            aws ssm get-command-invocation --command-id "$LOG_COMMAND_ID" --instance-id "${{ secrets.AWS_INSTANCE_ID }}" --query "StandardOutputContent" --output text
            exit 1
          fi