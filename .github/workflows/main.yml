# 워크플로우의 이름을 지정합니다. GitHub Actions 탭에 이 이름이 표시됩니다.
name: CI/CD for On-premise Webservice

# 워크플로우가 시작될 조건을 지정합니다.
on:
  # 'main' 브랜치에 push 이벤트가 발생했을 때 실행됩니다.
  push:
    branches: [ "main" ]

# 워크플로우에서 실행될 작업(job)들을 정의합니다.
jobs:
  # 1. CI: Docker 이미지를 빌드하고 AWS ECR에 푸시하는 작업
  build-and-push:
    # 이 작업이 실행될 가상 환경을 지정합니다. (최신 우분투)
    runs-on: ubuntu-latest
    # 작업의 출력을 정의하여 다른 작업에서 사용할 수 있도록 합니다.
    outputs:
      ecr_image_uri: ${{ steps.build-image.outputs.image }}
    steps:
      # 1-1. 소스 코드 체크아웃
      - name: Checkout source code
        uses: actions/checkout@v4

      # 1-2. AWS 자격 증명 설정
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # 1-3. Amazon ECR 로그인
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # 1-4. Docker 이미지 빌드, 태그 및 푸시
      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          # 이전 단계(login-ecr)의 출력인 레지스트리 주소를 사용합니다.
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          # 사용자가 생성한 ECR 리포지토리 이름으로 변경해야 합니다.
          ECR_REPOSITORY: gpdus4605/migration-webservice
          IMAGE_TAG: ${{ github.sha }}
        run: |
          cd backend
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          # 다음 작업에서 사용할 수 있도록 이미지 URI를 출력으로 설정합니다.
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

  # 2. CD: 운영 서버에 접속하여 최신 버전으로 배포하는 작업
  deploy:
    # 'build-and-push' 작업이 성공적으로 완료되어야 이 작업이 실행됩니다.
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      # 2-1. AWS 자격 증명 설정 (SSM 실행을 위해 필요)
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # 2-2. 배포 스크립트 실행
      - name: Execute deployment script
        env:
          # build-and-push 작업의 출력을 가져옵니다.
          ECR_IMAGE_URI: ${{ needs.build-and-push.outputs.ecr_image_uri }}
        run: |
          # .env 파일 내용을 Base64로 인코딩합니다.
          ENCODED_ENV=$(echo "${{ secrets.ENV_FILE_CONTENT }}" | base64 -w 0)
          
          # EC2 인스턴스에서 실행할 셸 스크립트를 정의합니다.
          # heredoc 내부에서 $ECR_IMAGE_URI 변수가 확장되도록 하여 deploy.sh에 인자로 전달합니다.
          REMOTE_SCRIPT=$(cat <<EOF
          set -e
          echo "### Starting deployment script on EC2 instance."

          APP_USER='${{ secrets.SSH_USERNAME }}'
          TARGET_DIR="/home/\$APP_USER/onpremise-webservice"

          echo "### Ensuring correct ownership of \$TARGET_DIR..."
          chown -R \$APP_USER:\$APP_USER "\$TARGET_DIR" || true

          if ! sudo -u \$APP_USER test -d "\$TARGET_DIR"; then
            echo "### Cloning repository..."
            sudo -u \$APP_USER git clone "https://github.com/${{ github.repository }}.git" "\$TARGET_DIR"
          else
            echo "### Setting remote URL..."
            sudo -u \$APP_USER git -C "\$TARGET_DIR" remote set-url origin "https://github.com/${{ github.repository }}.git"
            echo "### Pulling latest code..."
            sudo -u \$APP_USER git -C "\$TARGET_DIR" pull origin main
          fi

          echo "### Creating .env file..."
          echo "$ENCODED_ENV" | base64 --decode | sudo -u \$APP_USER tee "\$TARGET_DIR/.env" > /dev/null

          echo "### Running deployment script as root..."
          cd "\$TARGET_DIR/backend"
          # deploy.sh에 ECR 이미지 URI를 인자로 전달합니다.
          bash deploy.sh '$ECR_IMAGE_URI'

          echo "### Deployment script finished."
          EOF
          )

          # AWS CLI에 전달할 ssm-params.json 파일을 생성합니다.
          jq -n --arg script "$REMOTE_SCRIPT" \
            --argjson instance_ids '["${{ secrets.AWS_INSTANCE_ID }}"]' \
            '{ "DocumentName": "AWS-RunShellScript", "InstanceIds": $instance_ids, "Parameters": { "commands": [$script] } }' \
            > ssm-params.json

          echo "### Generated ssm-params.json:"
          cat ssm-params.json

          COMMAND_ID=$(aws ssm send-command \
            --cli-input-json file://ssm-params.json \
            --output text --query "Command.CommandId")

          echo "SSM Command ID for deployment: $COMMAND_ID"

          if ! aws ssm wait command-executed --command-id "$COMMAND_ID" --instance-id "${{ secrets.AWS_INSTANCE_ID }}"; then
            echo "--- Deployment failed. Fetching logs from SSM ---"
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ secrets.AWS_INSTANCE_ID }}" \
              --query "StandardErrorContent" \
              --output text
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ secrets.AWS_INSTANCE_ID }}" \
              --query "StandardOutputContent" \
              --output text
            exit 1
          fi

          echo "### Deployment command sent and executed successfully."