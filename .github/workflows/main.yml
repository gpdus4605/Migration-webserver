# 워크플로우의 이름을 지정합니다. GitHub Actions 탭에 이 이름이 표시됩니다.
name: CI/CD for On-premise Webservice

# 워크플로우가 시작될 조건을 지정합니다.
on:
  # 'main' 브랜치에 push 이벤트가 발생했을 때 실행됩니다.
  push:
    branches: [ "main" ]

# 워크플로우에서 실행될 작업(job)들을 정의합니다.
jobs:
  # 1. CI: Docker 이미지를 빌드하고 Docker Hub에 푸시하는 작업
  build-and-push:
    # 이 작업이 실행될 가상 환경을 지정합니다. (최신 우분투)
    runs-on: ubuntu-latest
    steps:
      # 1-1. 소스 코드 체크아웃
      # GitHub Repository에 있는 코드를 가상 환경으로 가져옵니다.
      - name: Checkout source code
        uses: actions/checkout@v4

      # 1-2. Docker Hub 로그인
      # GitHub Secrets에 저장된 Docker Hub 계정 정보를 사용하여 로그인합니다.
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # 1-3. Docker 이미지 빌드 및 푸시
      # Dockerfile을 사용하여 이미지를 빌드하고, Docker Hub에 푸시합니다.
      # 이미지 태그는 고유성을 위해 Git 커밋 해시(SHA)를 사용합니다.
      - name: Build and push Docker image
        run: |
          cd backend
          docker buildx build --file Dockerfile \
            --tag ${{ secrets.DOCKER_USERNAME }}/onpremise-webservice:${{ github.sha }} \
            --push .

  # 2. CD: 운영 서버에 접속하여 최신 버전으로 배포하는 작업
  deploy:
    # 'build-and-push' 작업이 성공적으로 완료되어야 이 작업이 실행됩니다.
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      # 2-1. AWS 자격 증명 설정
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # 2-2. 배포 스크립트 실행 (Git pull, .env 생성, 서비스 재시작)
      - name: Execute deployment script
        run: |
          # .env 파일 내용을 Base64로 인코딩합니다.
          ENCODED_ENV=$(echo "${{ secrets.ENV_FILE_CONTENT }}" | base64 -w 0)

          # EC2 인스턴스에서 실행할 셸 스크립트를 하나의 문자열로 정의합니다.
          REMOTE_SCRIPT=$(cat <<'EOF'
          set -e
          echo "### Starting deployment script on EC2 instance."

          # Git 소유권 문제 해결 (dubious ownership)
          # SSM 에이전트 사용자와 디렉토리 소유자가 다를 수 있으므로 안전한 디렉토리로 추가합니다.
          git config --global --add safe.directory /home/${{ secrets.SSH_USERNAME }}/onpremise-webservice

          # 작업 디렉토리로 이동합니다.
          if [ ! -d "/home/${{ secrets.SSH_USERNAME }}/onpremise-webservice" ]; then
            echo "### Cloning repository..."
            cd /home/${{ secrets.SSH_USERNAME }}
            git clone https://github.com/${{ github.repository }}.git onpremise-webservice
          else
            echo "### Pulling latest code..."
            cd /home/${{ secrets.SSH_USERNAME }}/onpremise-webservice
            git pull origin main
          fi
          
          # backend 디렉토리로 이동합니다.
          cd backend
          
          # Base64로 인코딩된 .env 파일 내용을 디코딩하여 .env 파일을 생성합니다.
          echo "### Creating .env file..."
          echo "$ENCODED_ENV" | base64 --decode > .env
          
          echo "### Verifying .env file content:"
          cat .env
          
          # deploy.sh 스크립트를 실행합니다.
          echo "### Executing deploy.sh..."
          export GITHUB_SHA="${{ github.sha }}"
          bash deploy.sh
          
          echo "### Deployment script finished."
          EOF
          )

          # AWS CLI에 전달할 ssm-params.json 파일을 생성합니다.
          # jq를 사용하여 REMOTE_SCRIPT를 JSON에 안전하게 삽입합니다.
          jq -n --arg script "$REMOTE_SCRIPT" \
            --argjson instance_ids '["${{ secrets.AWS_INSTANCE_ID }}"]' \
            '{ "DocumentName": "AWS-RunShellScript", "InstanceIds": $instance_ids, "Parameters": { "commands": [$script] } }' \
            > ssm-params.json

          echo "### Generated ssm-params.json:"
          cat ssm-params.json

          # --cli-input-json 옵션을 사용하여 원격 스크립트를 실행합니다.
          COMMAND_ID=$(aws ssm send-command \
            --cli-input-json file://ssm-params.json \
            --output text --query "Command.CommandId")

          echo "SSM Command ID for deployment: $COMMAND_ID"

          # 명령이 끝날 때까지 대기하고, 실패 시 로그를 가져옵니다.
          if ! aws ssm wait command-executed --command-id "$COMMAND_ID" --instance-id "${{ secrets.AWS_INSTANCE_ID }}"; then
            echo "--- Deployment failed. Fetching logs from SSM ---"
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ secrets.AWS_INSTANCE_ID }}" \
              --query "StandardErrorContent" \
              --output text
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ secrets.AWS_INSTANCE_ID }}" \
              --query "StandardOutputContent" \
              --output text
            exit 1
          fi

          echo "### Deployment command sent and executed successfully."
