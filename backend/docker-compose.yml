version: '3.8'

services:
  # 1. Nginx 리버스 프록시 서비스 정의
  nginx:
    image: nginx:alpine
    container_name: my-nginx
    ports:
      # 포트 번호를 직접 명시하여 변수 보간 문제를 원천적으로 제거합니다.
      - "80:80"
      - "443:443"
    volumes:
      # 로컬의 nginx 디렉터리를 컨테이너의 설정 디렉터리에 마운트합니다.
      - ./nginx:/etc/nginx/conf.d
      # frontend 디렉토리를 Nginx의 기본 웹 루트에 마운트합니다.
      - ../frontend:/usr/share/nginx/html
      # Nginx 로그를 호스트와 공유하기 위한 볼륨을 추가합니다.
      - ./log/nginx:/var/log/nginx
    depends_on:
      - api # api 서비스가 실행되어야 nginx가 정상적으로 프록시할 수 있습니다.
    env_file:
            - .env


  # 2. API 서버 서비스 정의
  api:
    # 현재 디렉터리의 Dockerfile을 사용하여 이미지를 빌드합니다.
    build: .
    # 컨테이너의 이름을 'my-api'로 지정합니다.
    container_name: my-api
    environment:
      FLASK_ENV: prod
    # 외부와 직접 통신하지 않으므로 ports 섹션을 제거하고, 대신 expose로 내부 포트를 명시합니다.
    expose:
      - "5000"
    # 아래 정의된 'db' 서비스가 먼저 시작된 후에 'api' 서비스를 시작합니다.
    depends_on:
      - db
    env_file:
            - .env


  # 3. PostgreSQL 데이터베이스 서비스 정의
  db:
    # Docker Hub에 있는 공식 PostgreSQL 14 이미지를 사용합니다.
    image: postgres:14-alpine
    container_name: my-postgres-db
    env_file:
            - .env

    # .env 파일에 정의된 DB_PORT(5433)를 컨테이너의 5432 포트로 연결합니다.
    ports:
      - "5433:5432"
    # 데이터베이스 데이터를 영속적으로 저장하기 위해 볼륨을 연결합니다.
    # 'postgres-data'라는 이름의 볼륨을 컨테이너의 '/var/lib/postgresql/data' 경로에 마운트합니다.
    volumes:
      - postgres-data:/var/lib/postgresql/data

# 4. Docker 볼륨 정의
volumes:
  postgres-data: